# ---------------------------строки---------------------------------#
'''
строка - это символов (буквы, цифры, спец.символы и т.д.), 
заключенный в кавычки '' "" '''''' """"""

'''
# s = "Это строка"
# print(s[0])
# # s[0] = '*' # TypeError: 'str' object does not support item assignment
# ''' замена символа'''
# s = s.replace('Э', '*')
# print(s)

# #—------------------------------- Задача —--------------------------------#
# '''
# дана строка вида 1110001100
# заменить все исходные 1 на 0
# заменить все исходные 0 на 1
#
# 1110001100 -> 0001110011
# '''
# test_string = '1110001100'
# # print(test_string)
# test_string = test_string.replace('1', '*')
# # print(test_string)
# test_string = test_string.replace('0', '1')
# # print(test_string)
# test_string = test_string.replace('*', '0')
# print(test_string)



# ------------------- методы строк ----------------------------#
# https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html



# #—------------------------------- Задача —--------------------------------#
# '''
# Однажды ковбой Джо нанялся в помощники шерифу. Шериф выдал ковбою Джо строку ﻿
#  и попросил собрать из её букв как можно больше слов
# sheriff
# sheriff. Каждая буква может использоваться не более одного раза.
#
# Ковбой Джо тут же приступил к заданию шерифа, но к сожалению, он не умеет читать. Помогите ковбою Джо.
#
#
#
# Формат входных данных
# Дана строка  состоящая из маленьких букв латинского алфавита.
#
# Формат выходных данных
# Выведите максимальное количество слов sheriff
#
#
#
# входных данных
# sbhercifcfasqherqifwf
#
# выходных данных
# 2
# '''
# '''
# sheriff
# s - 1
# h - 1
# e - 1
# r - 1
# i - 1
# f - 2
# '''
# s = 'sbhercifcfasqherqifwf'
# count_s = s.count('s')
# count_h = s.count('h')
# count_r = s.count('r')
# count_i = s.count('i')
# count_e = s.count('e')
# count_f = s.count('f')
# total_words = 0
# print(count_s)
# print(count_h)
# print(count_r)
# print(count_i)
# print(count_e)
# print(count_f)
# while count_s >= 1 and count_h >= 1 and count_r >= 1 and count_i >= 1 and count_e >= 1 and count_f >= 2:
#     total_words += 1
#     count_s -= 1
#     count_h -= 1
#     count_r -= 1
#     count_i -= 1
#     count_e -= 1
#     count_f -= 2
# print(f"всего получилось: {total_words} слова")


#
# # ------------------ срезы ------------------------- #
# '''
#
# '''
# #
# # s = '15:23'
# # #s[старт : конец : шаг]
# # print(s)
# # print('s[0:] = ', s[0:])
# # print('s[2::-1] = ', s[2::-1])
# # print('s[0:2] = ', s[0:2])
# # print('s[0:3:2] = ', s[0:3:2])
# # print('s[::-1] = ', s[::-1])
#
# # - через срезы
# s = '15:23:00'
# print(s)
# s_1 = s[0:s.find(':')]
# s_2 = s[s.find(':')+1:]
# print(s_1, s_2)
# s = s_1 + '-' + s_2
# print(s)
#
# # - через replace
# s = '15:23:00'
# s = s.replace(':', '-', 1)
# print(s)





#  ==========  3  ==========
'''
Написать программу, которая определяет представляет ли строка двоичное число.

Программа получает из stdin строку, содержащую один из нескольких 
возможных форматов строкового представления двоичного числа: без префикса, 
префикс 'b', префикс '0b'. 
Например:
    0101
    b11
    0b11001

Программа выводит в stdout текстовый ответ.

Пример ввода:
    1b0101

Пример вывода:
    нет
'''

'''
двоичное число: 
    состоит только из двух символов: 0, 1
    но может быть и префиксы: '', 'b', '0b' 

примеры валидных значений:
    0
    1
    0101
    b11
    0b11001 
    
примеры невалидных значений:
    0,1
    1.0
    0151
    c11
    1b11001 
    10101b
stdin = 'abdcx'
срез = берем срез по первым двум элементам строки
если есть 'b' в срезе, то
    проверяем где стоит 'b' в срезе (0 или 1)
    если стоит на 1-ой, то проверяем 0-ой элемент, он должен быть равен '0'
         для каждого символа в stdin за исчключением  0-ого и 1-ого элементов :
            проверяем, что он состоит только из 1 или 0, 
                stdout = 'да'
            иначе 
                stdout = 'нет'
    если нет
        stdout = 'нет'
    если на 0-ой, то    
        для каждого символа в stdin за исчключением  0-ого элемента :
            проверяем, что он состоит только из 1 или 0, 
                stdout = 'да'
            иначе 
                stdout = 'нет'
    
печатаем stdout

'''
#
# s = '0b11001'
#
# for el in s:
#     print(el)



#----------------------------Задача-------------------------------------#
'''
Проверка номера телефона:
Напишите регулярное выражение, которое проверяет, соответствует ли строка номеру телефона в формате 123-456-7890. 
На месте цифр могут стоят любые цифры

'''
import re
pattern = r'\d{3}\-\d{3}\-\d{4}'

# Определить соответствует ли строка данному шаблону
# test_string = '123-456-7890'
# print(re.match(pattern, test_string)) # -> <re.Match object; span=(0, 12), match='123-456-7890'>
# # None - говорит о том, что строка не соответствует шаблону
#
# print(re.fullmatch(pattern, test_string).group()) #.group() вытащит строку, соответствующую

# # -------------разница между fullmatch и match-----------------#
# import re
#
# string = "123-456-7890   fdf "
# pattern = r'\d{3}\-\d{3}\-\d{4}'
#
# print(re.match(pattern, string))
# print(re.fullmatch(pattern, string))




#
# # Найти все соответвия шаблону и записать их в список
# pattern = r'\d{3}\-\d{3}\-\d{4}'
# test_string = '''
# примеры валидных значений:
# 123-456-7890
# 000-000-0000
#
# примеры невалидных значений:
# 0-000-0000
# 000 000 0000
# 0000000000
# 000-0000000
# '''
#
#
# print(re.findall(pattern, test_string)) # ['123-456-7890', '000-000-0000']
#
#
# print(re.search(pattern, test_string)) # находит первое совпадение по шаблону
# print(re.split(pattern, test_string)) # сформирует список строк в качестве разделителя возьмет шаблон



#----------------------------Задача-------------------------------------#
'''
Поиск всех номеров кредитных карт:
Напишите программу, которое находит все номера кредитных карт в тексте 
и записывает их в виде чисел в список credit_cards.

номера карт имеют формат XXXX-XXXX-XXXX-XXXX
или XXXXXXXXXXXXXXXX, где X — цифра.

1111-2222-3333-4444
1111222233304444

['1111-2222-3333-4444',
'1111222233304444']
'''
pattern = r'(\b\d{16}\b)|(\b\d{4}\-\d{4}\-\d{4}\-\d{4}\b)'
test_string = '''
1111-2222-3333-4444
1111222233304444

111122223330444
1111-22-2233304444
111122223330444434324324
'''
matches = re.findall(pattern, test_string)
#print(matches) #
credit_crads = []
for element in matches:

    for card in element:
        if card: # Если строка не пустая
            credit_crads.append(int(card.replace('-', '')))
print(credit_crads)